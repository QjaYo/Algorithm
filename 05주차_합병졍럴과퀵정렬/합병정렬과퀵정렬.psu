Alg mergeSort(L)
Input: list L with n elements
Output: sorted list L
{
  if (L.size() > 1)
    L1,L2 := partition(L, n/2)
    mergeSort(L1)
    mergeSort(L2)
    L := merge(L1,L2)
}

Alg merge(L1, L2)
Input: sorted list L1, and L2 with n/2 elements each
Output: sorted list of (L1 U L2)
{
  L := empty list
  while (!L1.isEmpty() & !L2.isEmpty())
    if (L1.getFirst() <= L2.getFirst())
      L.addLast(L1.removeFirst())
    else
      L.addLast(L2.removeFirst())
  while(!L1.isEmpty())
    L.addLast(L1.removeFirst())
  while(!L2.isEmpty())
    L.addLast(L2.removeFirst())

  return L
}

Alg quickSort(L)
Input: list L with n elements
Output: sorted list L
{
  if (L.size() > 1)
    k := a position in L
    LT,EQ,GT := partition(L,k)
    quickSort(LT)
    quickSort(GT)
    L := merge(LT, EQ, GT)
  
    return
}

Alg partition(L, k)
Input: list L with n elements, position k of pivot
Output: sublists LT,EQ,GT of the elements of L
{
  p := L.get(k)
  LT,EQ,GT := empty list

  while(!L.isEmpty())
    e := L.removeFirst()
    if (e < p)
      LT.addLast(e)
    else if (e = p)
      EQ.addLast(e)
    else
      GT.addLast(e)
  
  return LT,EQ,GT
}

Alg inPlaceQuickSort(L, l, r)
Input: list L, position l,r
Output: sorted list L
{
  if (l >= r)
    return
  
  k := a position between [l, r]
  a,b := inPlacePartition(L, l, r, k) //a,b: index of first element of EQ,GT
  inPlaceQuickSort(L, l, a-1)
  inPlaceQuickSort(L, b+1, r)
}

Alg inPlacePartition_Lomuto(L, l, r, k)
Input: list L, range[l,r], pivot position k
Output: pivot position
{
  p := L[k]
  swap(L[k], L[r])

  gt := l     //start position of GT array

  for (int cur = l; cur <= r-1; cur++)
  {
    if (L[cur] < p)
      swap(L[gt],L[cur])
      gt++
  }

  swap(L[r], L[gt])
  return gt
}

Alg inPlacePartition_Hoare(L, l, r, k)
Input: list L, range[l,r], pivot position k
Output: EQ, GT position
{
  p := A[k]
  swap(A[k], A[r])
  i := l
  j := r-1
  while (i <= j)
    while (i <= j & A[i] <= p)
      i++
    while (i <= j & A[j] >= p)
      j--
    if (i < j)
      swap(A[i], A[j])
  swap(A[i], A[r])
  return i
}

Alg inPlacePartition_3way(L, l, r, k)
Input: list L, range[l,r], pivot position k
Output: pivot position
{
  p := A[k]
  swap(A[k], A[r])

  eq_start := l
  eq_end := r-1
  
  cur := l
  while (cur <= eq_end)
  {
    if (A[cur] < p)
    {
      swap(A[cur], A[eq_start])
      eq_start++
      cur++
    }
    else if (A[cur] > p)
    {
      swap(A[cur], A[eq_end])
      eq_end--
    }
    else
      cur++;
  }

  swap(A[eq_end+1], A[r])
  return eq_start, eq_end+1
}