//힙에 삽입
Alg insertItem(k)
Input: key k, node last
output: none
{
  advanceLast() //last := newLast
  z := last
  Set node z to k
  expandExternal(z)
  upHeap(z)
  return
}

Alg upHeap(v)
Input: node v
Output: none
{
  if (isRoot(v))
    return
  if (key(v) >= key(parent(v)))
    return
  swapElements(v, parent(v))
  upHeap(parent(v))
}

Alg expandExternal(w)
Input: external node w
Output: node
{
  l := getnode()
  l.left := null
  l.right := null
  l.parent := w
  w.left := l

  r := getnode()
  r.left := null
  r.right := null
  r.parent := w
  w.right := r

  return
}

Alg removeMin()
Input: node last
Output: key
{
  k := key(root())
  w := last
  Set root to key(w)
  retreatLast()
  z := rightChild(w)
  reduceExternal(z)
  downHeap(root())
  return k
}

Alg reduceExternal(z)
Input: external node z
Output: the node replacing the parent node of the removed node z
{
  w := z.parent
  zs := sibling(z)
  if (isRoot(w))
    root := zs
    zs.parent := null
  else
    g := w.parent
    zs.parent := g
    if (w = g.left)
      g.left := zs
    else
      g.right := zs
  putnode(z)
  putnode(w)
  return zs
}

Alg downHeap(v)
Input: node v
Output: a heap with root v
{
  if (isExternal(leftChild(v)) & isExternal(rightChild(v)))
    return
  smaller := leftChild(v)
  if (isInternal(rightChild(v)))
    if (key(rightChild(v)) < key(leftChild))
      smaller := rightChild(v)
  if (key(v) <= key(smaller))
    return
  swapElements(v, smaller)
  downHeap(smaller)
}

//재귀식 상향식 힙생성
Alg buildHeap(L)
Input: list L storing n keys
Output: heap T storing the keys in L
{
  T := convertToCompleteBinaryTree(L)
  rBuildHeap(T.root())
  return T
}

Alg rBuildHeap(v)
Input: node v
Output: a heap with root v
{
  if (isInternal(v))
    rBuildHeap(leftChild(v))
    rBuildHeap(rightChild(v))
    downHeap(v)
  return
}

//비재귀식 상향식 힙생성(정렬되어야할 리스트가 배열로 주어진 경우에만 적용 가능)
Alg buildHeap(A)
Input: array A of n keys
Output: heap A of size n
{
  for i := floor(n/2) downto 1
    downHeap(i, n)
  return
}

Alg inPlaceHeapSort(A)
Input: array A of n keys
Output: sorted array A
{
  buildHeap(A)
  for i := n downto 2
    swap(A[1], A[i])
    downHeap(1, i-1)
  return
}

